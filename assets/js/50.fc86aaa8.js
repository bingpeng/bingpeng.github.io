(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{447:function(t,a,r){"use strict";r.r(a);var v=r(2),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("Boxx"),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#镜像（image）"}},[t._v("镜像（Image）")]),r("ul",[r("li",[r("a",{attrs:{href:"#分层存储"}},[t._v("分层存储")])]),r("li",[r("a",{attrs:{href:"#删除层"}},[t._v("删除层")])])])]),r("li",[r("a",{attrs:{href:"#容器（container）"}},[t._v("容器（Container）")]),r("ul",[r("li",[r("a",{attrs:{href:"#运行细节"}},[t._v("运行细节")])]),r("li",[r("a",{attrs:{href:"#容器存储层"}},[t._v("容器存储层")])])])])])]),r("p"),t._v(" "),r("p",[t._v("Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。")]),t._v(" "),r("p",[t._v("Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。")]),t._v(" "),r("p",[t._v("对于生信领域来说，docker的出现极大地减少了关于软件环境调试的时间，解放了生产力，可以让用户专注于使用相应工具解决对应生物学问题，而不是和系统环境与各种包版本斗智斗勇。")]),t._v(" "),r("p",[t._v("当然，仅针对软件环境和版本，conda也能解决一部分这种问题，但在一些开发环境迁移和生产环境的部署上，docker能提供的解决方案显然更优。")]),t._v(" "),r("h2",{attrs:{id:"镜像（image）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#镜像（image）"}},[t._v("#")]),t._v(" 镜像（Image）")]),t._v(" "),r("p",[t._v("Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。")]),t._v(" "),r("h3",{attrs:{id:"分层存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层存储"}},[t._v("#")]),t._v(" 分层存储")]),t._v(" "),r("p",[t._v("镜像有时候会包含整个操作系统，这个时候存储体积就会非常庞大。比如针对软件1，软件2（含操作系统文件）分别封装两个镜像，就会将操作系统打包两次，这个不利于存储和复用。")]),t._v(" "),r("p",[t._v("镜像是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层")]),t._v(" "),r("p",[t._v("分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。")]),t._v(" "),r("h3",{attrs:{id:"删除层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除层"}},[t._v("#")]),t._v(" 删除层")]),t._v(" "),r("p",[t._v("删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。")]),t._v(" "),r("p",[t._v("在构建镜像的时候，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。")]),t._v(" "),r("h2",{attrs:{id:"容器（container）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器（container）"}},[t._v("#")]),t._v(" 容器（Container）")]),t._v(" "),r("p",[t._v("镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 "),r("strong",[t._v("类")]),t._v(" 和 "),r("strong",[t._v("实例")]),t._v(" 一样，镜像是静态的定义，容器是镜像运行时的实体。")]),t._v(" "),r("p",[t._v("容器可以被创建、启动、停止、删除、暂停等。")]),t._v(" "),r("h3",{attrs:{id:"运行细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行细节"}},[t._v("#")]),t._v(" 运行细节")]),t._v(" "),r("p",[t._v("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。")]),t._v(" "),r("p",[t._v("每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为"),r("strong",[t._v("容器存储层")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"容器存储层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器存储层"}},[t._v("#")]),t._v(" 容器存储层")]),t._v(" "),r("p",[t._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")]),t._v(" "),r("p",[t._v("容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用"),r("strong",[t._v("数据卷（Volume）")]),t._v("、或者"),r("strong",[t._v("绑定宿主目录")]),t._v("。")])],1)}),[],!1,null,null,null);a.default=_.exports}}]);