(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{436:function(a,t,s){"use strict";s.r(t);var e=s(2),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("Boxx"),a._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#启动容器"}},[a._v("启动容器")]),s("ul",[s("li",[s("a",{attrs:{href:"#直接执行命令"}},[a._v("直接执行命令")])]),s("li",[s("a",{attrs:{href:"#开启交互式终端"}},[a._v("开启交互式终端")])]),s("li",[s("a",{attrs:{href:"#从终止的容器中运行"}},[a._v("从终止的容器中运行")])]),s("li",[s("a",{attrs:{href:"#后台运行"}},[a._v("后台运行")])])])]),s("li",[s("a",{attrs:{href:"#终止运行"}},[a._v("终止运行")])]),s("li",[s("a",{attrs:{href:"#删除容器"}},[a._v("删除容器")])]),s("li",[s("a",{attrs:{href:"#进入容器"}},[a._v("进入容器")]),s("ul",[s("li",[s("a",{attrs:{href:"#attach"}},[a._v("attach")])]),s("li",[s("a",{attrs:{href:"#exec"}},[a._v("exec")])])])]),s("li",[s("a",{attrs:{href:"#导出和导入"}},[a._v("导出和导入")]),s("ul",[s("li",[s("a",{attrs:{href:"#导出容器"}},[a._v("导出容器")])]),s("li",[s("a",{attrs:{href:"#导入容器快照"}},[a._v("导入容器快照")])])])])])]),s("p"),a._v(" "),s("p",[a._v("容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。")]),a._v(" "),s("h2",{attrs:{id:"启动容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启动容器"}},[a._v("#")]),a._v(" 启动容器")]),a._v(" "),s("p",[a._v("当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：")]),a._v(" "),s("ul",[s("li",[a._v("检查本地是否存在指定的镜像，不存在就从 registry 下载")]),a._v(" "),s("li",[a._v("利用镜像创建并启动一个容器")]),a._v(" "),s("li",[a._v("分配一个文件系统，并在只读的镜像层外面挂载一层可读写层")]),a._v(" "),s("li",[a._v("从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去")]),a._v(" "),s("li",[a._v("从地址池配置一个 ip 地址给容器")]),a._v(" "),s("li",[a._v("执行用户指定的应用程序")]),a._v(" "),s("li",[a._v("执行完毕后容器被终止")])]),a._v(" "),s("h3",{attrs:{id:"直接执行命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接执行命令"}},[a._v("#")]),a._v(" 直接执行命令")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('docker run ubuntu:latest /bin/echo "Hello world"\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"开启交互式终端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开启交互式终端"}},[a._v("#")]),a._v(" 开启交互式终端")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("docker run -it ubuntu:latest /bin/bash\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。")]),a._v(" "),s("p",[a._v("在交互模式下，用户可以通过所创建的终端来输入命令.")]),a._v(" "),s("h3",{attrs:{id:"从终止的容器中运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从终止的容器中运行"}},[a._v("#")]),a._v(" 从终止的容器中运行")]),a._v(" "),s("p",[a._v("利用 docker container start 命令，直接将一个已经终止（exited）的容器启动运行。")]),a._v(" "),s("h3",{attrs:{id:"后台运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后台运行"}},[a._v("#")]),a._v(" 后台运行")]),a._v(" "),s("p",[a._v("让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。")])]),a._v(" "),s("h2",{attrs:{id:"终止运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#终止运行"}},[a._v("#")]),a._v(" 终止运行")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("docker container stop\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("ul",[s("li",[a._v("当Docker容器中指定的应用终结时，容器也自动终止")]),a._v(" "),s("li",[a._v("用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止")])]),a._v(" "),s("p",[a._v("处于终止状态的容器，可以通过 docker container start 命令来重新启动。")]),a._v(" "),s("p",[a._v("此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。")]),a._v(" "),s("h2",{attrs:{id:"删除容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除容器"}},[a._v("#")]),a._v(" 删除容器")]),a._v(" "),s("p",[a._v("可以使用 docker container rm 来删除一个处于终止状态的容器。例如：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("docker container rm trusting_newton\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("清理所有处于终止状态的容器")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("docker container prune\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h2",{attrs:{id:"进入容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进入容器"}},[a._v("#")]),a._v(" 进入容器")]),a._v(" "),s("p",[a._v("使用docker attach或者docker exec")]),a._v(" "),s("h3",{attrs:{id:"attach"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#attach"}},[a._v("#")]),a._v(" attach")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('$ docker run -dit ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n\n$ docker container ls\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia\n\n$ docker attach 243c\nroot@243c32535da7:/#\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("如果从这个 stdin 中 exit，会导致容器的停止。")])]),a._v(" "),s("h3",{attrs:{id:"exec"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exec"}},[a._v("#")]),a._v(" exec")]),a._v(" "),s("p",[a._v("docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。")]),a._v(" "),s("p",[a._v("只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。")]),a._v(" "),s("p",[a._v("当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("如果从这个 stdin 中 exit，不会导致容器的停止。")])]),a._v(" "),s("h2",{attrs:{id:"导出和导入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导出和导入"}},[a._v("#")]),a._v(" 导出和导入")]),a._v(" "),s("h3",{attrs:{id:"导出容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导出容器"}},[a._v("#")]),a._v(" 导出容器")]),a._v(" "),s("p",[a._v("导出本地某个容器，可以使用 docker export 命令。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('$ docker container ls -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES\n7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test\n$ docker export 7691a814370e > ubuntu.tar\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("h3",{attrs:{id:"导入容器快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导入容器快照"}},[a._v("#")]),a._v(" 导入容器快照")]),a._v(" "),s("p",[a._v("使用 docker import 从容器快照文件中再导入为镜像")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("$ cat ubuntu.tar | docker import - test/ubuntu:v1.0\n$ docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE\ntest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。")]),a._v(" "),s("p",[a._v("这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。")]),a._v(" "),s("p",[a._v("此外，从容器快照文件导入时可以重新指定标签等元数据信息。")])])],1)}),[],!1,null,null,null);t.default=r.exports}}]);